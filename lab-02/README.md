# Лабораторная работа №2

## Задание 1

Написать программу, реализующую алгоритм AES.

## Задание 2

Оптимизировать программу из задания 1 по времени выполнения.

# Симметричный алгоритм блочного шифрования Advanced Encryption Standart

AES — шифр не-Файстеля, который зашифровывает и расшифровывает блок данных 128 битов, используя 10, 12 или 14 раундов. Размер ключа может быть 128, 192 или 256 битов и зависит от номера раунда. Рисунок 9.1 показывает общую схему: алгоритм шифрования (называемого шифром); алгоритм дешифрования (называемый обратным шифром), для которого применяются те же ключи, но в обратном порядке.

![](https://intuit.ru/EDI/18_03_16_6/1458253316-18142/tutorial/576/objects/9/files/9-1.gif)

Число ключей раунда, сгенерированных алгоритмом расширения ключей, всегда на один больше, чем число раундов. Другими словами, мы имеем

`номер ключей раунда = Nr + 1`

Мы обозначаем ключи раунда как `K0, K1, K2..., KN`.

## Единицы данных

AES использует пять единиц для представления данных: биты, байты, слова, блоки и массивы состояний. 

* **Бит** — двоичная цифра со значением 0 или 1. Мы используем строчные буквы для обозначения бит.

* **Байт** — группа из восьми битов, которая может быть обработана как единый объект: матрица из одной строки (1x8) восьми битов или столбец матрицы (8x1) из восьми битов. 

*Когда информация байта обрабатываются как матрица строки, то биты вставляются в матрице слева направо. Когда байт обрабатывается как матрица столбца, биты вставляются в матрице сверху вниз.*

* **Слово** — группа из 32 битов, которая может быть обработана как единый объект. Это матрица из строки в четыре байта или столбец матрицы из четырех байтов. 

*Когда слово обрабатывается как матрица-строка, байты вставляются слева направо. Когда слово представляется матрицей-колонкой, байты вставляются сверху вниз.*

`AES зашифровывает и расшифровывает блоки данных.`

* **Блок** — группа 128 битов. Однако блок может быть представлен как матрица-строка из 16-ти байтов.

![](https://intuit.ru/EDI/18_03_16_6/1458253316-18142/tutorial/576/objects/9/files/9-2.gif)


### Матрица состояний

AES использует несколько раундов, каждый раунд состоит из нескольких каскадов. Блок данных преобразовывается от одного каскада к другому. 

В начале и в конце шифра AES применяется термин блок данных; до и после каждого каскада блок данных называется матрицей состояний.

Матрицы состояний, подобно блокам, состоят из 16 байтов, но обычно обрабатываются как матрицы 4X4 байтов. В этом случае каждый элемент матрицы состояний обозначается как S_{r,c}, где **r** (от 0 до 3) определяет строку и **c** (от 0 до 3) определяет столбец. 

Иногда матрица состояний обрабатывается как матрица-строка слов (1x4). Это имеет смысл, если мы представляем слово как матрицу-столбец. 

![](https://intuit.ru/EDI/18_03_16_6/1458253316-18142/tutorial/576/objects/9/files/9-3.gif)

## Структура каждого раунда

Каждый раунд — это набор шагов (преобразований) над матрицей байтов (состоянием).

Обычно раунд выглядит так:
* `SubBytes` — заменяем каждый байт на другой по таблице (S-box).
* `ShiftRows` — сдвигаем строки матрицы.
* `MixColumns` — перемешиваем данные по столбцам.
* `AddRoundKey` — накладываем кусок ключа.

В самом начале (до первого раунда) выполняется только `AddRoundKey` (чтобы сразу «подмешать» ключ).

В последних раунде шаг `MixColumns` пропускается, остаются только три операции (SubBytes, ShiftRows, AddRoundKey).

Каждое преобразование принимает матрицу состояний и создает другую матрицу состояний, которая применяется для следующего преобразования или следующего раунда.

![](https://intuit.ru/EDI/18_03_16_6/1458253316-18142/tutorial/576/objects/9/files/9-5.gif)

### Схема

          ┌─────────────┐
          │ AddRoundKey │   ← начальный шаг (только один)
          └──────┬──────┘
                 │
      ┌──────────▼──────────┐
      │      Раунд 1        │
      │ SubBytes            │
      │ ShiftRows           │
      │ MixColumns          │
      │ AddRoundKey         │
      └──────────┬──────────┘
                 │
                 ⋮
                 │
      ┌──────────▼──────────┐
      │   Предпоследний     │
      │ SubBytes            │
      │ ShiftRows           │
      │ MixColumns          │
      │ AddRoundKey         │
      └──────────┬──────────┘
                 │
      ┌──────────▼──────────┐
      │   Последний раунд   │
      │ SubBytes            │
      │ ShiftRows           │
      │ AddRoundKey         │
      └─────────────────────┘

## Преобразования

Чтобы обеспечить безопасность, AES использует четыре типа преобразований: подстановка, перестановка, смешивание и добавление ключа.

### Подстановка

Первое преобразование, `SubBytes`, используется на стороне шифрования.

* Каждый байт можно записать как две шестнадцатеричные цифры.

Например, байт 10101100₂ = AC₁₆.

* Первая цифра (A) указывает строку в таблице, вторая (C) — столбец в таблице S-box (16×16).

* В этой ячейке находится новое значение байта — это и есть результат подстановки.

Пример:

    Байт 0x53 → первая цифра 5, вторая 3.
    Смотрим таблицу S-box: строка 5, колонка 3.
    Там, например, лежит 0xED.
    Значит, после SubBytes наш байт 0x53 превращается в 0xED.

![](https://intuit.ru/EDI/18_03_16_6/1458253316-18142/tutorial/576/objects/9/files/9-6.gif)

Операция SubByte включает 16 **независимых** преобразований байта в байт.

* Обратимость — `InvSubBytes`

Есть обратная таблица (InvS-box). Она устроена так, что если подать на неё результат замены, то обратно получим исходный байт. Это позволяет дешифровать AES.

![](https://intuit.ru/EDI/18_03_16_6/1458253316-18142/tutorial/576/objects/9/files/9-7.gif)

---

#### Построение S-box в AES

##### 1. Что такое S-box

S-box в AES — это **таблица подстановок** (Substitution box).  
Она берёт входной байт (8 бит) и заменяет его на другой байт по определённым правилам.  
В AES эта таблица содержит 256 значений (по одному для каждого байта).

---

##### 2. Основная идея
В AES S-box строится в два этапа:
1. **Мультипликативная инверсия в поле GF(2⁸)**  
2. **Аффинное преобразование**

---

###### Шаг 1 — Мультипликативная инверсия в поле GF(2⁸)

- Байты рассматриваются как элементы поля GF(2⁸).  
- В поле GF(2⁸) все байты (кроме 0) имеют обратный элемент по умножению.  
- Если байт — число a, то находим такое a⁻¹, что: a × a⁻¹ = 1 (в поле GF(2⁸)).

**Почему это важно:**  

Инверсия — нелинейная операция. Она даёт сильное непредсказуемое преобразование, что критично для криптографической стойкости.

**Пример:**  
Если вход — `0x53`, его мультипликативная инверсия в GF(2⁸) может быть `0xCA` (пример, фактическое значение вычисляется по алгоритму поля).

**Важно:** 0 не имеет обратного элемента → по определению S-box заменяет его на 0.

---

###### Шаг 2 — Аффинное преобразование

После инверсии байт проходит линейное преобразование (матрица × вектор + вектор).  

Формула:

`b′ᵢ = bᵢ XOR b₍ᵢ₊₄₎ mod 8 XOR b₍ᵢ₊₅₎ mod 8 XOR b₍ᵢ₊₆₎ mod 8 XOR b₍ᵢ₊₇₎ mod 8 XOR cᵢ`

Где:
* `bᵢ` — i-й бит байта после инверсии
* `cᵢ` — i-й бит постоянного байта 0x63
* `XOR` — операция исключающего ИЛИ

**Проще говоря:**  
Берётся байт после инверсии, к нему применяется фиксированное линейное преобразование (сдвиги + XOR).

---

После этих двух шагов байт преобразуется в новый байт.  

**Пример:**  

    0x53 → Инверсия в GF(2^8) → 0xCA → Аффинное преобразование → 0xED

    В таблице S-box: `S[0x53] = 0xED`.

- **Инверсия в GF(2⁸)** даёт сильную нелинейность.  
- **Аффинное преобразование** усиливает диффузию.  
- Вместе они делают S-box стойким к известным атакам (например, дифференциальному и линейному криптоанализу).

---

Для дешифрования нужен обратный S-box (InvSubBytes).  

Он строится в обратном порядке:
1. Обратное аффинное преобразование  
2. Мультипликативная инверсия в GF(2⁸)

Это гарантирует: `InvSubBytes(S-box(x)) = x`

--- 

### Перестановка

**ShiftRows** - перестановка байтов в матрице состояния при шифровании.

* Направление: сдвиг влево.
* Число сдвигов: зависит от номера строки матрицы состояния:

        Строка 0: не сдвигается.
        Строка 1: сдвиг на 1 байт влево.
        Строка 2: сдвиг на 2 байта влево.
        Строка 3: сдвиг на 3 байта влево.

* Работает по одной строке одновременно.
* Улучшает диффузию данных.

Пример:

    До ShiftRows:

    [a0 a1 a2 a3]
    [b0 b1 b2 b3]
    [c0 c1 c2 c3]
    [d0 d1 d2 d3]

    После ShiftRows:

    [a0 a1 a2 a3]
    [b1 b2 b3 b0]
    [c2 c3 c0 c1]
    [d3 d0 d1 d2]

![](https://intuit.ru/EDI/18_03_16_6/1458253316-18142/tutorial/576/objects/9/files/9-9.gif)
---

**InvShiftRows** - обратная перестановка байтов при дешифровании.

* Направление: сдвиг вправо.
* Число сдвигов: равно номеру строки матрицы состояния:

        Строка 0: не сдвигается.
        Строка 1: сдвиг на 1 байт вправо.
        Строка 2: сдвиг на 2 байта вправо.
        Строка 3: сдвиг на 3 байта вправо.

* Инверсно преобразованию ShiftRows.
* Восстанавливает исходный порядок байтов.

`InvShiftRows(ShiftRows(state)) = state`

### Cмешивание

`MixColumns` — это внутри-столбцовое преобразование.

`MixColumns` обеспечивает:
* Распространение влияния каждого байта на весь столбец.
* Усиление криптографической стойкости за счёт «разрушения» структуры данных.
* Дифузию на уровне битов.

---

Матрица состояния AES имеет размер **4×4 байта**.  

Преобразование `MixColumns` выполняется по **столбцам**, каждый из которых является вектором из 4 байт:

Столбец `C = [s0, s1, s2, s3]^T`

Где:
- `s0` — первый байт столбца
- `s1` — второй байт столбца
- `s2` — третий байт столбца
- `s3` — четвёртый байт столбца

`MixColumns` заменяет этот столбец на новый, вычисляя:

`C' = M × C`

Где `M` — фиксированная **матрица констант**.

---

#### Матрица констант MixColumns

    M = 
    [ 02 03 01 01 ]
    [ 01 02 03 01 ]
    [ 01 01 02 03 ]
    [ 03 01 01 02 ]

Эта матрица определена стандартом AES.

---

Каждый байт нового столбца вычисляется как **сумма умножений байтов исходного столбца на константы**.  
Умножение и сложение выполняются в поле GF(2^8) по модулю `0x11B`.

Например, первый байт нового столбца (`s0'`) вычисляется так:

`s0' = (02 • s0) ⊕ (03 • s1) ⊕ (01 • s2) ⊕ (01 • s3)`

Где:
- `•` — умножение в GF(2^8)
- `⊕` — побитовое XOR (сложение в GF(2^8))

Аналогично для остальных байтов:

`s1' = (01 • s0) ⊕ (02 • s1) ⊕ (03 • s2) ⊕ (01 • s3)`

`s2' = (01 • s0) ⊕ (01 • s1) ⊕ (02 • s2) ⊕ (03 • s3)`

`s3' = (03 • s0) ⊕ (01 • s1) ⊕ (01 • s2) ⊕ (02 • s3)`

Таким образом каждый новый байт зависит от **всех четырёх исходных байтов столбца**.

#### Обратное преобразование — InvMixColumns

Для восстановления исходного столбца при дешифровании используется обратная матрица констант:

    InvMixColumns матрица:
    [ 0e 0b 0d 09 ]
    [ 09 0e 0b 0d ]
    [ 0d 09 0e 0b ]
    [ 0b 0d 09 0e ]

`InvMixColumns(MixColumns(C)) = C`

---

### Добавление ключа

`AddRoundKey` — одно из ключевых преобразований AES, которое обеспечивает связь между ключом шифрования и данными. Это преобразование добавляет (XOR) ключ раунда к состоянию.


* Каждый раунд шифрования AES использует свой ключ раунда.
* Ключи раунда получаются из исходного ключа методом ключевого расширения (Key Expansion).
* AddRoundKey выполняется на уровне столбцов матрицы состояния.
* Для каждого столбца состояния выполняется операция XOR с соответствующим словом ключа раунда.

`AddRoundKey` — самоинверсное преобразование: применение его дважды восстанавливает исходное состояние.

`XOR` выполняется побайтно.

Преобразование не изменяет структуру матрицы состояния, а только изменяет её содержимое на основе ключа раунда.

#### Алгоритм

Для каждого столбца состояния:

```
for (c = 0 to 3)
    state[c] = state[c] ⊕ roundKey[c]
```

Где:
- `state[c]` — c-й столбец матрицы состояния (4 байта).
- `roundKey[c]` — c-й столбец ключа раунда (4 байта).
- `⊕` — операция побайтного XOR.

## Расширение ключей (Key Expansion)

* Генерация набора ключей для каждого раунда из исходного ключа.
* AES-128 → 11 ключей по 128 бит.

* AES-128: 44 слова (w0 … w43)
* Первые 4 слова — исходный ключ.

###  Распределение слов по раундам
    Раунд	    Слова
    0	    w0, w1, w2, w3
    1	    w4, w5, w6, w7
    2	    w8, w9, w10, w11
    …	           …
    10	    w40, w41, w42, w43

### Процесс генерации

#### Шаг 1
    Первые 4 слова — исходный ключ:

    w0 = k0 k1 k2 k3  
    w1 = k4 k5 k6 k7  
    w2 = k8 k9 k10 k11  
    w3 = k12 k13 k14 k15
#### Шаг 2

    Для i = 4 … 43:
        Если i кратно 4:
            w[i] = SubWord(RotWord(w[i-1])) XOR Rcon[i/4] XOR w[i-4]
        Иначе:
            w[i] = w[i-1] XOR w[i-4]

#### Операции

`RotWord(word)` — циклический сдвиг байт слова влево на 1 позицию.

*Пример*

    RotWord(13 AA 54 87) = AA 54 87 13

`SubWord(word)` — замена каждого байта слова через S-box.

`Rcon[n]` — константа раунда:

    Rcon[1] = 01 00 00 00
    Rcon[2] = 02 00 00 00
    Rcon[3] = 04 00 00 00
    Rcon[4] = 08 00 00 00
    Rcon[5] = 10 00 00 00
    Rcon[6] = 20 00 00 00
    Rcon[7] = 40 00 00 00
    Rcon[8] = 80 00 00 00
    Rcon[9] = 1B 00 00 00
    Rcon[10]= 36 00 00 00

#### Псевдокод
`KeyExpansion(key)`

    for i from 0 to 3:
        w[i] = key[4*i .. 4*i+3]

    for i from 4 to 43:
        temp = w[i-1]
        if i mod 4 == 0:
            temp = SubWord(RotWord(temp)) XOR Rcon[i/4]
        w[i] = w[i-4] XOR temp

    return w[0..43]
    
#### Особенности

* Каждый ключ раунда зависит от предыдущих слов.
* `SubWord` и `Rcon` делают зависимость нелинейной — повышает безопасность.
* Малейшее изменение исходного ключа меняет все ключи раундов.

![](https://intuit.ru/EDI/18_03_16_6/1458253316-18142/tutorial/576/objects/10/files/10-2.gif)